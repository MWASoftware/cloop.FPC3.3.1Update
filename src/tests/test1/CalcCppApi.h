// This file was autogenerated by cloop - Cross Language Object Oriented Programming

#ifndef CALC_CPP_API_H
#define CALC_CPP_API_H

#include <stdint.h>


template <typename Policy>
class CalcApi
{
public:
	// Interfaces declarations

	class Disposable
	{
	protected:
		struct VTable
		{
			void* cloopDummy[1];
			uintptr_t version;
			void (*dispose)(Disposable* self);
		};

	protected:
		void* cloopDummy[1];
		VTable* cloopVTable;

	public:
		static const int VERSION = 1;

		void dispose()
		{
			Policy::template checkVersion<1>(this);
			static_cast<VTable*>(this->cloopVTable)->dispose(this);
		}
	};

	class Status : public Disposable
	{
	protected:
		struct VTable : public Disposable::VTable
		{
			int (*getCode)(Status* self);
			void (*setCode)(Status* self, int code);
		};

	public:
		static const int VERSION = 3;

		int getCode()
		{
			Policy::template checkVersion<2>(this);
			int ret = static_cast<VTable*>(this->cloopVTable)->getCode(this);
			return ret;
		}

		void setCode(int code)
		{
			Policy::template checkVersion<3>(this);
			static_cast<VTable*>(this->cloopVTable)->setCode(this, code);
		}
	};

	class Calculator : public Disposable
	{
	protected:
		struct VTable : public Disposable::VTable
		{
			int (*sum)(Calculator* self, Status* status, int n1, int n2);
			int (*getMemory)(Calculator* self);
			void (*setMemory)(Calculator* self, int n);
			void (*sumAndStore)(Calculator* self, Status* status, int n1, int n2);
		};

	public:
		static const int VERSION = 5;

		int sum(Status* status, int n1, int n2)
		{
			Policy::template checkVersion<2>(this);
			int ret = static_cast<VTable*>(this->cloopVTable)->sum(this, status, n1, n2);
			Policy::checkException(status);
			return ret;
		}

		int getMemory()
		{
			Policy::template checkVersion<3>(this);
			int ret = static_cast<VTable*>(this->cloopVTable)->getMemory(this);
			return ret;
		}

		void setMemory(int n)
		{
			Policy::template checkVersion<4>(this);
			static_cast<VTable*>(this->cloopVTable)->setMemory(this, n);
		}

		void sumAndStore(Status* status, int n1, int n2)
		{
			Policy::template checkVersion<5>(this);
			static_cast<VTable*>(this->cloopVTable)->sumAndStore(this, status, n1, n2);
			Policy::checkException(status);
		}
	};

	class Calculator2 : public Calculator
	{
	protected:
		struct VTable : public Calculator::VTable
		{
			int (*multiply)(Calculator2* self, Status* status, int n1, int n2);
			void (*copyMemory)(Calculator2* self, Calculator* calculator);
		};

	public:
		static const int VERSION = 7;

		int multiply(Status* status, int n1, int n2)
		{
			Policy::template checkVersion<5>(this);
			int ret = static_cast<VTable*>(this->cloopVTable)->multiply(this, status, n1, n2);
			Policy::checkException(status);
			return ret;
		}

		void copyMemory(Calculator* calculator)
		{
			Policy::template checkVersion<6>(this);
			static_cast<VTable*>(this->cloopVTable)->copyMemory(this, calculator);
		}
	};

	// Interfaces implementations

	template <typename Name, typename Base>
	class DisposableBaseImpl : public Base
	{
	public:
		DisposableBaseImpl()
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->dispose = &Name::cloopdisposeDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void cloopdisposeDispatcher(Disposable* self) throw()
		{
			static_cast<Name*>(self)->Name::dispose();
		}
	};

	template <typename Name, typename Base = Disposable>
	class DisposableImpl : public DisposableBaseImpl<Name, Base>
	{
	public:
		virtual ~DisposableImpl()
		{
		}

		virtual void dispose() = 0;
	};

	template <typename Name, typename Base>
	class StatusBaseImpl : public Base
	{
	public:
		StatusBaseImpl()
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->getCode = &Name::cloopgetCodeDispatcher;
					this->setCode = &Name::cloopsetCodeDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int cloopgetCodeDispatcher(Status* self) throw()
		{
			return static_cast<Name*>(self)->Name::getCode();
		}

		static void cloopsetCodeDispatcher(Status* self, int code) throw()
		{
			static_cast<Name*>(self)->Name::setCode(code);
		}
	};

	template <typename Name, typename Base = DisposableImpl<Name, Status> >
	class StatusImpl : public StatusBaseImpl<Name, Base>
	{
	public:
		virtual ~StatusImpl()
		{
		}

		virtual int getCode() = 0;
		virtual void setCode(int code) = 0;
	};

	template <typename Name, typename Base>
	class CalculatorBaseImpl : public Base
	{
	public:
		CalculatorBaseImpl()
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->sum = &Name::cloopsumDispatcher;
					this->getMemory = &Name::cloopgetMemoryDispatcher;
					this->setMemory = &Name::cloopsetMemoryDispatcher;
					this->sumAndStore = &Name::cloopsumAndStoreDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int cloopsumDispatcher(Calculator* self, Status* status, int n1, int n2) throw()
		{
			return static_cast<Name*>(self)->Name::sum(status, n1, n2);
		}

		static int cloopgetMemoryDispatcher(Calculator* self) throw()
		{
			return static_cast<Name*>(self)->Name::getMemory();
		}

		static void cloopsetMemoryDispatcher(Calculator* self, int n) throw()
		{
			static_cast<Name*>(self)->Name::setMemory(n);
		}

		static void cloopsumAndStoreDispatcher(Calculator* self, Status* status, int n1, int n2) throw()
		{
			static_cast<Name*>(self)->Name::sumAndStore(status, n1, n2);
		}
	};

	template <typename Name, typename Base = DisposableImpl<Name, Calculator> >
	class CalculatorImpl : public CalculatorBaseImpl<Name, Base>
	{
	public:
		virtual ~CalculatorImpl()
		{
		}

		virtual int sum(Status* status, int n1, int n2) = 0;
		virtual int getMemory() = 0;
		virtual void setMemory(int n) = 0;
		virtual void sumAndStore(Status* status, int n1, int n2) = 0;
	};

	template <typename Name, typename Base>
	class Calculator2BaseImpl : public Base
	{
	public:
		Calculator2BaseImpl()
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->sum = &Name::cloopsumDispatcher;
					this->getMemory = &Name::cloopgetMemoryDispatcher;
					this->setMemory = &Name::cloopsetMemoryDispatcher;
					this->sumAndStore = &Name::cloopsumAndStoreDispatcher;
					this->multiply = &Name::cloopmultiplyDispatcher;
					this->copyMemory = &Name::cloopcopyMemoryDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int cloopmultiplyDispatcher(Calculator2* self, Status* status, int n1, int n2) throw()
		{
			return static_cast<Name*>(self)->Name::multiply(status, n1, n2);
		}

		static void cloopcopyMemoryDispatcher(Calculator2* self, Calculator* calculator) throw()
		{
			static_cast<Name*>(self)->Name::copyMemory(calculator);
		}
	};

	template <typename Name, typename Base = CalculatorImpl<Name, DisposableImpl<Name, Calculator2> > >
	class Calculator2Impl : public Calculator2BaseImpl<Name, Base>
	{
	public:
		virtual ~Calculator2Impl()
		{
		}

		virtual int multiply(Status* status, int n1, int n2) = 0;
		virtual void copyMemory(Calculator* calculator) = 0;
	};
};


#endif	// CALC_CPP_API_H
