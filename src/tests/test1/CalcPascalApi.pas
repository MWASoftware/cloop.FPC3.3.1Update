{ This file was autogenerated by cloop - Cross Language Object Oriented Programming }

{ $DEFINE USEFBEXCEPTION}
{ $DEFINE STATIC_LINK_TO_FIREBIRD_LIBRARY}

{$WARNINGS OFF}
{$IFDEF FPC}
{$MODE DELPHI}
{$ENDIF}

{$IFDEF MSWINDOWS}
{$DEFINE WINDOWS}
{$ENDIF}

unit CalcPascalApi;

interface

uses Classes, SysUtils;

type
{$IFNDEF FPC}
	QWord = UInt64;
{$ENDIF}

	Disposable = ^TDisposable;
	Status = ^TStatus;
	StatusFactory = ^TStatusFactory;
	Factory = ^TFactory;
	Calculator = ^TCalculator;
	Calculator2 = ^TCalculator2;

CalcException = class(Exception)
public
	constructor create(code: Integer);

	function getCode: Integer;

	class procedure checkException(status: Status);
	class procedure catchException(status: Status; e: Exception);

private
	code: Integer;
end;

	IntegerPtr = ^Integer;

	Disposable_disposePtr = procedure(this: Disposable); cdecl;
	Status_getCodePtr = function(this: Status): Integer; cdecl;
	Status_setCodePtr = procedure(this: Status; code: Integer); cdecl;
	StatusFactory_createStatusPtr = function(this: StatusFactory): Status; cdecl;
	Factory_createStatusPtr = function(this: Factory): Status; cdecl;
	Factory_createCalculatorPtr = function(this: Factory; status: Status): Calculator; cdecl;
	Factory_createCalculator2Ptr = function(this: Factory; status: Status): Calculator2; cdecl;
	Factory_createBrokenCalculatorPtr = function(this: Factory; status: Status): Calculator; cdecl;
	Factory_setStatusFactoryPtr = procedure(this: Factory; statusFactory: StatusFactory); cdecl;
	Calculator_sumPtr = function(this: Calculator; status: Status; n1: Integer; n2: Integer): Integer; cdecl;
	Calculator_getMemoryPtr = function(this: Calculator): Integer; cdecl;
	Calculator_setMemoryPtr = procedure(this: Calculator; n: Integer); cdecl;
	Calculator_sumAndStorePtr = procedure(this: Calculator; status: Status; n1: Integer; n2: Integer); cdecl;
	Calculator2_multiplyPtr = function(this: Calculator2; status: Status; n1: Integer; n2: Integer): Integer; cdecl;
	Calculator2_copyMemoryPtr = procedure(this: Calculator2; calculator: Calculator); cdecl;
	Calculator2_copyMemory2Ptr = procedure(this: Calculator2; address: IntegerPtr); cdecl;

	PDisposableVTable = ^DisposableVTable;
	DisposableVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: Disposable_disposePtr;
	end;

	DisposableImpl = class;

	TDisposable = record
	private
	  FNullPtr: pointer;
	  FvTable: PDisposableVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: Disposable; inline;
	public
	  function isDisposableImpl: boolean;
	  function asDisposableImpl: DisposableImpl;
	  property vTable: PDisposableVTable read FvTable;
	public
	  {interface constants accessed using inline functions}
	  function VERSION: NativeInt; inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	end;

	DisposableImpl = class
	private
	  FNullPtr: pointer;
	  FvTable: pointer;
	  FObject: TObject;
	  function getVTable: PDisposableVTable;
	public
	  const VERSION = 1;
	public
	  constructor create;
	  function asDisposable: Disposable;
	  class function isDisposableImpl(intf: Disposable): boolean;
	  property vTable: PDisposableVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure dispose(); virtual; abstract;
	end;

	PStatusVTable = ^StatusVTable;
	StatusVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: Disposable_disposePtr;
	  getCode: Status_getCodePtr;
	  setCode: Status_setCodePtr;
	end;

	StatusImpl = class;

	TStatus = record
	private
	  FNullPtr: pointer;
	  FvTable: PStatusVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: Status; inline;
	public
	  function isStatusImpl: boolean;
	  function asStatusImpl: StatusImpl;
	  property vTable: PStatusVTable read FvTable;
	public
	  {interface constants accessed using inline functions}
	  function VERSION: NativeInt; inline;
	  function ERROR_1: Integer; inline;
	  function ERROR_2: Integer; inline;
	  function ERROR_12: Integer; inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  function getCode(): Integer;
	  procedure setCode(code: Integer);
	end;

	StatusImpl = class(DisposableImpl)
	private
	  function getVTable: PStatusVTable;
	public
	  const VERSION = 3;
	  const ERROR_1 = Integer(1);
	  const ERROR_2 = Integer($2);
	  const ERROR_12 = Integer(StatusImpl.ERROR_1 or StatusImpl.ERROR_2);
	public
	  constructor create;
	  function asStatus: Status;
	  class function isStatusImpl(intf: Status): boolean;
	  property vTable: PStatusVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getCode(): Integer; virtual; abstract;
	  procedure setCode(code: Integer); virtual; abstract;
	end;

	PStatusFactoryVTable = ^StatusFactoryVTable;
	StatusFactoryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: Disposable_disposePtr;
	  createStatus: StatusFactory_createStatusPtr;
	end;

	StatusFactoryImpl = class;

	TStatusFactory = record
	private
	  FNullPtr: pointer;
	  FvTable: PStatusFactoryVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: StatusFactory; inline;
	public
	  function isStatusFactoryImpl: boolean;
	  function asStatusFactoryImpl: StatusFactoryImpl;
	  property vTable: PStatusFactoryVTable read FvTable;
	public
	  {interface constants accessed using inline functions}
	  function VERSION: NativeInt; inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  function createStatus(): Status;
	end;

	StatusFactoryImpl = class(DisposableImpl)
	private
	  function getVTable: PStatusFactoryVTable;
	public
	  const VERSION = 2;
	public
	  constructor create;
	  function asStatusFactory: StatusFactory;
	  class function isStatusFactoryImpl(intf: StatusFactory): boolean;
	  property vTable: PStatusFactoryVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function createStatus(): Status; virtual; abstract;
	end;

	PFactoryVTable = ^FactoryVTable;
	FactoryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: Disposable_disposePtr;
	  createStatus: Factory_createStatusPtr;
	  createCalculator: Factory_createCalculatorPtr;
	  createCalculator2: Factory_createCalculator2Ptr;
	  createBrokenCalculator: Factory_createBrokenCalculatorPtr;
	  setStatusFactory: Factory_setStatusFactoryPtr;
	end;

	FactoryImpl = class;

	TFactory = record
	private
	  FNullPtr: pointer;
	  FvTable: PFactoryVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: Factory; inline;
	public
	  function isFactoryImpl: boolean;
	  function asFactoryImpl: FactoryImpl;
	  property vTable: PFactoryVTable read FvTable;
	public
	  {interface constants accessed using inline functions}
	  function VERSION: NativeInt; inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  function createStatus(): Status;
	  function createCalculator(status: Status): Calculator;
	  function createCalculator2(status: Status): Calculator2;
	  function createBrokenCalculator(status: Status): Calculator;
	  procedure setStatusFactory(statusFactory: StatusFactory);
	end;

	FactoryImpl = class(DisposableImpl)
	private
	  function getVTable: PFactoryVTable;
	public
	  const VERSION = 6;
	public
	  constructor create;
	  function asFactory: Factory;
	  class function isFactoryImpl(intf: Factory): boolean;
	  property vTable: PFactoryVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function createStatus(): Status; virtual; abstract;
	  function createCalculator(status: Status): Calculator; virtual; abstract;
	  function createCalculator2(status: Status): Calculator2; virtual; abstract;
	  function createBrokenCalculator(status: Status): Calculator; virtual; abstract;
	  procedure setStatusFactory(statusFactory: StatusFactory); virtual; abstract;
	end;

	PCalculatorVTable = ^CalculatorVTable;
	CalculatorVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: Disposable_disposePtr;
	  sum: Calculator_sumPtr;
	  getMemory: Calculator_getMemoryPtr;
	  setMemory: Calculator_setMemoryPtr;
	  sumAndStore: Calculator_sumAndStorePtr;
	end;

	CalculatorImpl = class;

	TCalculator = record
	private
	  FNullPtr: pointer;
	  FvTable: PCalculatorVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: Calculator; inline;
	public
	  function isCalculatorImpl: boolean;
	  function asCalculatorImpl: CalculatorImpl;
	  property vTable: PCalculatorVTable read FvTable;
	public
	  {interface constants accessed using inline functions}
	  function VERSION: NativeInt; inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  function sum(status: Status; n1: Integer; n2: Integer): Integer;
	  function getMemory(): Integer;
	  procedure setMemory(n: Integer);
	  procedure sumAndStore(status: Status; n1: Integer; n2: Integer);
	end;

	CalculatorImpl = class(DisposableImpl)
	private
	  function getVTable: PCalculatorVTable;
	public
	  const VERSION = 5;
	public
	  constructor create;
	  function asCalculator: Calculator;
	  class function isCalculatorImpl(intf: Calculator): boolean;
	  property vTable: PCalculatorVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function sum(status: Status; n1: Integer; n2: Integer): Integer; virtual; abstract;
	  function getMemory(): Integer; virtual; abstract;
	  procedure setMemory(n: Integer); virtual; abstract;
	  procedure sumAndStore(status: Status; n1: Integer; n2: Integer); virtual; abstract;
	end;

	PCalculator2VTable = ^Calculator2VTable;
	Calculator2VTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: Disposable_disposePtr;
	  sum: Calculator_sumPtr;
	  getMemory: Calculator_getMemoryPtr;
	  setMemory: Calculator_setMemoryPtr;
	  sumAndStore: Calculator_sumAndStorePtr;
	  multiply: Calculator2_multiplyPtr;
	  copyMemory: Calculator2_copyMemoryPtr;
	  copyMemory2: Calculator2_copyMemory2Ptr;
	end;

	Calculator2Impl = class;

	TCalculator2 = record
	private
	  FNullPtr: pointer;
	  FvTable: PCalculator2VTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: Calculator2; inline;
	public
	  function isCalculator2Impl: boolean;
	  function asCalculator2Impl: Calculator2Impl;
	  property vTable: PCalculator2VTable read FvTable;
	public
	  {interface constants accessed using inline functions}
	  function VERSION: NativeInt; inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  function sum(status: Status; n1: Integer; n2: Integer): Integer;
	  function getMemory(): Integer;
	  procedure setMemory(n: Integer);
	  procedure sumAndStore(status: Status; n1: Integer; n2: Integer);
	  function multiply(status: Status; n1: Integer; n2: Integer): Integer;
	  procedure copyMemory(calculator: Calculator);
	  procedure copyMemory2(address: IntegerPtr);
	end;

	Calculator2Impl = class(CalculatorImpl)
	private
	  function getVTable: PCalculator2VTable;
	public
	  const VERSION = 8;
	public
	  constructor create;
	  function asCalculator2: Calculator2;
	  class function isCalculator2Impl(intf: Calculator2): boolean;
	  property vTable: PCalculator2VTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function multiply(status: Status; n1: Integer; n2: Integer): Integer; virtual; abstract;
	  procedure copyMemory(calculator: Calculator); virtual; abstract;
	  procedure copyMemory2(address: IntegerPtr); virtual; abstract;
	end;


implementation

resourcestring
	errNotImplementationObject = 'interface is not an implementation of %s';

function TDisposable.this: Disposable;
begin
  Result := Disposable(@FNullPtr);
end;

function TDisposable.isDisposableImpl: boolean;
begin
  Result := DisposableImpl.isDisposableImpl(this);
end;

function TDisposable.asDisposableImpl: DisposableImpl;
begin
  if isDisposableImpl then
    Result := FObject as DisposableImpl
  else
    raise CalcException.CreateFmt(errNotImplementationObject,['DisposableImpl']);
end;

function TDisposable.VERSION: NativeInt;
begin
  Result := DisposableImpl.VERSION;
end;

procedure TDisposable.dispose();
begin
	vTable^.dispose(this);
end;

function TStatus.this: Status;
begin
  Result := Status(@FNullPtr);
end;

function TStatus.isStatusImpl: boolean;
begin
  Result := StatusImpl.isStatusImpl(this);
end;

function TStatus.asStatusImpl: StatusImpl;
begin
  if isStatusImpl then
    Result := FObject as StatusImpl
  else
    raise CalcException.CreateFmt(errNotImplementationObject,['StatusImpl']);
end;

function TStatus.VERSION: NativeInt;
begin
  Result := StatusImpl.VERSION;
end;

function TStatus.ERROR_1: Integer;
begin
  Result := StatusImpl.ERROR_1;
end;

function TStatus.ERROR_2: Integer;
begin
  Result := StatusImpl.ERROR_2;
end;

function TStatus.ERROR_12: Integer;
begin
  Result := StatusImpl.ERROR_12;
end;

procedure TStatus.dispose();
begin
	vTable^.dispose(Disposable(this));
end;

function TStatus.getCode(): Integer;
begin
	Result := vTable^.getCode(this);
end;

procedure TStatus.setCode(code: Integer);
begin
	vTable^.setCode(this, code);
end;

function TStatusFactory.this: StatusFactory;
begin
  Result := StatusFactory(@FNullPtr);
end;

function TStatusFactory.isStatusFactoryImpl: boolean;
begin
  Result := StatusFactoryImpl.isStatusFactoryImpl(this);
end;

function TStatusFactory.asStatusFactoryImpl: StatusFactoryImpl;
begin
  if isStatusFactoryImpl then
    Result := FObject as StatusFactoryImpl
  else
    raise CalcException.CreateFmt(errNotImplementationObject,['StatusFactoryImpl']);
end;

function TStatusFactory.VERSION: NativeInt;
begin
  Result := StatusFactoryImpl.VERSION;
end;

procedure TStatusFactory.dispose();
begin
	vTable^.dispose(Disposable(this));
end;

function TStatusFactory.createStatus(): Status;
begin
	Result := vTable^.createStatus(this);
end;

function TFactory.this: Factory;
begin
  Result := Factory(@FNullPtr);
end;

function TFactory.isFactoryImpl: boolean;
begin
  Result := FactoryImpl.isFactoryImpl(this);
end;

function TFactory.asFactoryImpl: FactoryImpl;
begin
  if isFactoryImpl then
    Result := FObject as FactoryImpl
  else
    raise CalcException.CreateFmt(errNotImplementationObject,['FactoryImpl']);
end;

function TFactory.VERSION: NativeInt;
begin
  Result := FactoryImpl.VERSION;
end;

procedure TFactory.dispose();
begin
	vTable^.dispose(Disposable(this));
end;

function TFactory.createStatus(): Status;
begin
	Result := vTable^.createStatus(this);
end;

function TFactory.createCalculator(status: Status): Calculator;
begin
	Result := vTable^.createCalculator(this, status);
	{$IFDEF USEFBEXCEPTION}CalcException.checkException(status);{$ENDIF}
end;

function TFactory.createCalculator2(status: Status): Calculator2;
begin
	Result := vTable^.createCalculator2(this, status);
	{$IFDEF USEFBEXCEPTION}CalcException.checkException(status);{$ENDIF}
end;

function TFactory.createBrokenCalculator(status: Status): Calculator;
begin
	Result := vTable^.createBrokenCalculator(this, status);
	{$IFDEF USEFBEXCEPTION}CalcException.checkException(status);{$ENDIF}
end;

procedure TFactory.setStatusFactory(statusFactory: StatusFactory);
begin
	vTable^.setStatusFactory(this, statusFactory);
end;

function TCalculator.this: Calculator;
begin
  Result := Calculator(@FNullPtr);
end;

function TCalculator.isCalculatorImpl: boolean;
begin
  Result := CalculatorImpl.isCalculatorImpl(this);
end;

function TCalculator.asCalculatorImpl: CalculatorImpl;
begin
  if isCalculatorImpl then
    Result := FObject as CalculatorImpl
  else
    raise CalcException.CreateFmt(errNotImplementationObject,['CalculatorImpl']);
end;

function TCalculator.VERSION: NativeInt;
begin
  Result := CalculatorImpl.VERSION;
end;

procedure TCalculator.dispose();
begin
	vTable^.dispose(Disposable(this));
end;

function TCalculator.sum(status: Status; n1: Integer; n2: Integer): Integer;
begin
	Result := vTable^.sum(this, status, n1, n2);
	{$IFDEF USEFBEXCEPTION}CalcException.checkException(status);{$ENDIF}
end;

function TCalculator.getMemory(): Integer;
begin
	Result := vTable^.getMemory(this);
end;

procedure TCalculator.setMemory(n: Integer);
begin
	vTable^.setMemory(this, n);
end;

procedure TCalculator.sumAndStore(status: Status; n1: Integer; n2: Integer);
begin
	vTable^.sumAndStore(this, status, n1, n2);
	{$IFDEF USEFBEXCEPTION}CalcException.checkException(status);{$ENDIF}
end;

function TCalculator2.this: Calculator2;
begin
  Result := Calculator2(@FNullPtr);
end;

function TCalculator2.isCalculator2Impl: boolean;
begin
  Result := Calculator2Impl.isCalculator2Impl(this);
end;

function TCalculator2.asCalculator2Impl: Calculator2Impl;
begin
  if isCalculator2Impl then
    Result := FObject as Calculator2Impl
  else
    raise CalcException.CreateFmt(errNotImplementationObject,['Calculator2Impl']);
end;

function TCalculator2.VERSION: NativeInt;
begin
  Result := Calculator2Impl.VERSION;
end;

procedure TCalculator2.dispose();
begin
	vTable^.dispose(Disposable(this));
end;

function TCalculator2.sum(status: Status; n1: Integer; n2: Integer): Integer;
begin
	Result := vTable^.sum(Calculator(this), status, n1, n2);
	{$IFDEF USEFBEXCEPTION}CalcException.checkException(status);{$ENDIF}
end;

function TCalculator2.getMemory(): Integer;
begin
	Result := vTable^.getMemory(Calculator(this));
end;

procedure TCalculator2.setMemory(n: Integer);
begin
	vTable^.setMemory(Calculator(this), n);
end;

procedure TCalculator2.sumAndStore(status: Status; n1: Integer; n2: Integer);
begin
	vTable^.sumAndStore(Calculator(this), status, n1, n2);
	{$IFDEF USEFBEXCEPTION}CalcException.checkException(status);{$ENDIF}
end;

function TCalculator2.multiply(status: Status; n1: Integer; n2: Integer): Integer;
begin
	Result := vTable^.multiply(this, status, n1, n2);
	{$IFDEF USEFBEXCEPTION}CalcException.checkException(status);{$ENDIF}
end;

procedure TCalculator2.copyMemory(calculator: Calculator);
begin
	vTable^.copyMemory(this, calculator);
end;

procedure TCalculator2.copyMemory2(address: IntegerPtr);
begin
	vTable^.copyMemory2(this, address);
end;

function DisposableImpl.asDisposable:Disposable;
begin
  Result := Disposable(@FNullPtr);
end;

procedure DisposableImpl_disposeDispatcher(this: Disposable); cdecl;
begin
	try
		this.asDisposableImpl.dispose();
	except
		on e: Exception do CalcException.catchException(nil, e);
	end
end;

var DisposableImpl_vTable: DisposableVTable = (
     NullPtr: nil;
     version: 1;
     dispose: DisposableImpl_disposeDispatcher);

constructor DisposableImpl.create;
begin
  inherited Create;
  FObject := self;
  FvTable := @DisposableImpl_vTable;
end;

function DisposableImpl.getVTable: PDisposableVTable;
begin
  Result := PDisposableVTable(FvTable);
end;

class function DisposableImpl.isDisposableImpl(intf: Disposable): boolean;
begin
  Result := (intf.vTable = @DisposableImpl_vTable) or
    StatusImpl.isStatusImpl(Status(intf)) or
    StatusFactoryImpl.isStatusFactoryImpl(StatusFactory(intf)) or
    FactoryImpl.isFactoryImpl(Factory(intf)) or
    CalculatorImpl.isCalculatorImpl(Calculator(intf));
end;

function StatusImpl.asStatus:Status;
begin
  Result := Status(@FNullPtr);
end;

procedure StatusImpl_disposeDispatcher(this: Status); cdecl;
begin
	try
		this.asStatusImpl.dispose();
	except
		on e: Exception do CalcException.catchException(nil, e);
	end
end;

function StatusImpl_getCodeDispatcher(this: Status): Integer; cdecl;
begin
	try
		Result := this.asStatusImpl.getCode();
	except
		on e: Exception do CalcException.catchException(nil, e);
	end
end;

procedure StatusImpl_setCodeDispatcher(this: Status; code: Integer); cdecl;
begin
	try
		this.asStatusImpl.setCode(code);
	except
		on e: Exception do CalcException.catchException(nil, e);
	end
end;

var StatusImpl_vTable: StatusVTable = (
     NullPtr: nil;
     version: 3;
     dispose: DisposableImpl_disposeDispatcher;
     getCode: StatusImpl_getCodeDispatcher;
     setCode: StatusImpl_setCodeDispatcher);

constructor StatusImpl.create;
begin
  inherited Create;
  FvTable := @StatusImpl_vTable;
end;

function StatusImpl.getVTable: PStatusVTable;
begin
  Result := PStatusVTable(FvTable);
end;

class function StatusImpl.isStatusImpl(intf: Status): boolean;
begin
  Result := (intf.vTable = @StatusImpl_vTable);
end;

function StatusFactoryImpl.asStatusFactory:StatusFactory;
begin
  Result := StatusFactory(@FNullPtr);
end;

procedure StatusFactoryImpl_disposeDispatcher(this: StatusFactory); cdecl;
begin
	try
		this.asStatusFactoryImpl.dispose();
	except
		on e: Exception do CalcException.catchException(nil, e);
	end
end;

function StatusFactoryImpl_createStatusDispatcher(this: StatusFactory): Status; cdecl;
begin
	try
		Result := this.asStatusFactoryImpl.createStatus();
	except
		on e: Exception do CalcException.catchException(nil, e);
	end
end;

var StatusFactoryImpl_vTable: StatusFactoryVTable = (
     NullPtr: nil;
     version: 2;
     dispose: DisposableImpl_disposeDispatcher;
     createStatus: StatusFactoryImpl_createStatusDispatcher);

constructor StatusFactoryImpl.create;
begin
  inherited Create;
  FvTable := @StatusFactoryImpl_vTable;
end;

function StatusFactoryImpl.getVTable: PStatusFactoryVTable;
begin
  Result := PStatusFactoryVTable(FvTable);
end;

class function StatusFactoryImpl.isStatusFactoryImpl(intf: StatusFactory): boolean;
begin
  Result := (intf.vTable = @StatusFactoryImpl_vTable);
end;

function FactoryImpl.asFactory:Factory;
begin
  Result := Factory(@FNullPtr);
end;

procedure FactoryImpl_disposeDispatcher(this: Factory); cdecl;
begin
	try
		this.asFactoryImpl.dispose();
	except
		on e: Exception do CalcException.catchException(nil, e);
	end
end;

function FactoryImpl_createStatusDispatcher(this: Factory): Status; cdecl;
begin
	try
		Result := this.asFactoryImpl.createStatus();
	except
		on e: Exception do CalcException.catchException(nil, e);
	end
end;

function FactoryImpl_createCalculatorDispatcher(this: Factory; status: Status): Calculator; cdecl;
begin
	try
		Result := this.asFactoryImpl.createCalculator(status);
	except
		on e: Exception do CalcException.catchException(status, e);
	end
end;

function FactoryImpl_createCalculator2Dispatcher(this: Factory; status: Status): Calculator2; cdecl;
begin
	try
		Result := this.asFactoryImpl.createCalculator2(status);
	except
		on e: Exception do CalcException.catchException(status, e);
	end
end;

function FactoryImpl_createBrokenCalculatorDispatcher(this: Factory; status: Status): Calculator; cdecl;
begin
	try
		Result := this.asFactoryImpl.createBrokenCalculator(status);
	except
		on e: Exception do CalcException.catchException(status, e);
	end
end;

procedure FactoryImpl_setStatusFactoryDispatcher(this: Factory; statusFactory: StatusFactory); cdecl;
begin
	try
		this.asFactoryImpl.setStatusFactory(statusFactory);
	except
		on e: Exception do CalcException.catchException(nil, e);
	end
end;

var FactoryImpl_vTable: FactoryVTable = (
     NullPtr: nil;
     version: 6;
     dispose: DisposableImpl_disposeDispatcher;
     createStatus: FactoryImpl_createStatusDispatcher;
     createCalculator: FactoryImpl_createCalculatorDispatcher;
     createCalculator2: FactoryImpl_createCalculator2Dispatcher;
     createBrokenCalculator: FactoryImpl_createBrokenCalculatorDispatcher;
     setStatusFactory: FactoryImpl_setStatusFactoryDispatcher);

constructor FactoryImpl.create;
begin
  inherited Create;
  FvTable := @FactoryImpl_vTable;
end;

function FactoryImpl.getVTable: PFactoryVTable;
begin
  Result := PFactoryVTable(FvTable);
end;

class function FactoryImpl.isFactoryImpl(intf: Factory): boolean;
begin
  Result := (intf.vTable = @FactoryImpl_vTable);
end;

function CalculatorImpl.asCalculator:Calculator;
begin
  Result := Calculator(@FNullPtr);
end;

procedure CalculatorImpl_disposeDispatcher(this: Calculator); cdecl;
begin
	try
		this.asCalculatorImpl.dispose();
	except
		on e: Exception do CalcException.catchException(nil, e);
	end
end;

function CalculatorImpl_sumDispatcher(this: Calculator; status: Status; n1: Integer; n2: Integer): Integer; cdecl;
begin
	try
		Result := this.asCalculatorImpl.sum(status, n1, n2);
	except
		on e: Exception do CalcException.catchException(status, e);
	end
end;

function CalculatorImpl_getMemoryDispatcher(this: Calculator): Integer; cdecl;
begin
	try
		Result := this.asCalculatorImpl.getMemory();
	except
		on e: Exception do CalcException.catchException(nil, e);
	end
end;

procedure CalculatorImpl_setMemoryDispatcher(this: Calculator; n: Integer); cdecl;
begin
	try
		this.asCalculatorImpl.setMemory(n);
	except
		on e: Exception do CalcException.catchException(nil, e);
	end
end;

procedure CalculatorImpl_sumAndStoreDispatcher(this: Calculator; status: Status; n1: Integer; n2: Integer); cdecl;
begin
	try
		this.asCalculatorImpl.sumAndStore(status, n1, n2);
	except
		on e: Exception do CalcException.catchException(status, e);
	end
end;

var CalculatorImpl_vTable: CalculatorVTable = (
     NullPtr: nil;
     version: 5;
     dispose: DisposableImpl_disposeDispatcher;
     sum: CalculatorImpl_sumDispatcher;
     getMemory: CalculatorImpl_getMemoryDispatcher;
     setMemory: CalculatorImpl_setMemoryDispatcher;
     sumAndStore: CalculatorImpl_sumAndStoreDispatcher);

constructor CalculatorImpl.create;
begin
  inherited Create;
  FvTable := @CalculatorImpl_vTable;
end;

function CalculatorImpl.getVTable: PCalculatorVTable;
begin
  Result := PCalculatorVTable(FvTable);
end;

class function CalculatorImpl.isCalculatorImpl(intf: Calculator): boolean;
begin
  Result := (intf.vTable = @CalculatorImpl_vTable) or
    Calculator2Impl.isCalculator2Impl(Calculator2(intf));
end;

function Calculator2Impl.asCalculator2:Calculator2;
begin
  Result := Calculator2(@FNullPtr);
end;

procedure Calculator2Impl_disposeDispatcher(this: Calculator2); cdecl;
begin
	try
		this.asCalculator2Impl.dispose();
	except
		on e: Exception do CalcException.catchException(nil, e);
	end
end;

function Calculator2Impl_sumDispatcher(this: Calculator2; status: Status; n1: Integer; n2: Integer): Integer; cdecl;
begin
	try
		Result := this.asCalculator2Impl.sum(status, n1, n2);
	except
		on e: Exception do CalcException.catchException(status, e);
	end
end;

function Calculator2Impl_getMemoryDispatcher(this: Calculator2): Integer; cdecl;
begin
	try
		Result := this.asCalculator2Impl.getMemory();
	except
		on e: Exception do CalcException.catchException(nil, e);
	end
end;

procedure Calculator2Impl_setMemoryDispatcher(this: Calculator2; n: Integer); cdecl;
begin
	try
		this.asCalculator2Impl.setMemory(n);
	except
		on e: Exception do CalcException.catchException(nil, e);
	end
end;

procedure Calculator2Impl_sumAndStoreDispatcher(this: Calculator2; status: Status; n1: Integer; n2: Integer); cdecl;
begin
	try
		this.asCalculator2Impl.sumAndStore(status, n1, n2);
	except
		on e: Exception do CalcException.catchException(status, e);
	end
end;

function Calculator2Impl_multiplyDispatcher(this: Calculator2; status: Status; n1: Integer; n2: Integer): Integer; cdecl;
begin
	try
		Result := this.asCalculator2Impl.multiply(status, n1, n2);
	except
		on e: Exception do CalcException.catchException(status, e);
	end
end;

procedure Calculator2Impl_copyMemoryDispatcher(this: Calculator2; calculator: Calculator); cdecl;
begin
	try
		this.asCalculator2Impl.copyMemory(calculator);
	except
		on e: Exception do CalcException.catchException(nil, e);
	end
end;

procedure Calculator2Impl_copyMemory2Dispatcher(this: Calculator2; address: IntegerPtr); cdecl;
begin
	try
		this.asCalculator2Impl.copyMemory2(address);
	except
		on e: Exception do CalcException.catchException(nil, e);
	end
end;

var Calculator2Impl_vTable: Calculator2VTable = (
     NullPtr: nil;
     version: 8;
     dispose: DisposableImpl_disposeDispatcher;
     sum: CalculatorImpl_sumDispatcher;
     getMemory: CalculatorImpl_getMemoryDispatcher;
     setMemory: CalculatorImpl_setMemoryDispatcher;
     sumAndStore: CalculatorImpl_sumAndStoreDispatcher;
     multiply: Calculator2Impl_multiplyDispatcher;
     copyMemory: Calculator2Impl_copyMemoryDispatcher;
     copyMemory2: Calculator2Impl_copyMemory2Dispatcher);

constructor Calculator2Impl.create;
begin
  inherited Create;
  FvTable := @Calculator2Impl_vTable;
end;

function Calculator2Impl.getVTable: PCalculator2VTable;
begin
  Result := PCalculator2VTable(FvTable);
end;

class function Calculator2Impl.isCalculator2Impl(intf: Calculator2): boolean;
begin
  Result := (intf.vTable = @Calculator2Impl_vTable);
end;

constructor CalcException.create(code: Integer);
begin
	self.code := code;
end;

function CalcException.getCode: Integer;
begin
	Result := code;
end;

class procedure CalcException.checkException(status: Status);
var
	code: Integer;
begin
	code := status.getCode();

	if (code <> 0) then
		raise CalcException.create(code);
end;

class procedure CalcException.catchException(status: Status; e: Exception);
begin
	if (e.inheritsFrom(CalcException)) then
		status.setCode(CalcException(e).code)
	else
		status.setCode(-1);
end;

end.
